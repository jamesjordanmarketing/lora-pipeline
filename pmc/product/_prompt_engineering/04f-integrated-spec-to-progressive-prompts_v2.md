# Meta-Prompt: Integrated Spec Sections to Progressive Build Prompts

**Version:** 2.0  
**Date:** December 25, 2025  
**Purpose:** Transform integrated specification section files into progressive, executable build prompts  
**Target Agent:** Claude Sonnet 4.5 (200k context window)  
**Input Format:** Section files from `04f-segment-integrated-spec_v3.js` output  
**Output Format:** Progressive build prompts executable in fresh windows

---

## Overview

This meta-prompt analyzes structured integrated specification section files and generates progressive build prompts. Each prompt is designed to be executed in a fresh Claude Sonnet 4.5 window with 200k token context, building upon previous work in an explicit, integrative manner.

**Key Differences from v1**:
- **Input**: Structured section files (not unstructured specs)
- **Scope**: Works both within sections AND across sections
- **Format**: Sections already contain detailed specs with code examples
- **Strategy**: Breaks large sections into manageable chunks
- **Integration**: Explicit tracking of inter-section and intra-section dependencies

---

## Input Format

This meta-prompt expects section files generated by `04f-segment-integrated-spec_v3.js`:

### Section File Structure

```markdown
# Build Section E[NN]

**Product**: [PRODUCT-ABBREV]  
**Section**: [N] - [Title]  
**Generated**: [Date]  
**Source**: [Source file]

---

## SECTION [N]: [Title] - INTEGRATED

**Extension Status**: [Status]  
**Original Infrastructure**: [What was generic]  
**Actual Infrastructure**: [What we're actually using]

---

### Overview (from original spec)
[Description of what this section implements]

**What Already Exists**: [Listed items]
**What We're Adding**: [Listed items]

---

### Dependencies

**Codebase Prerequisites** (MUST exist before this section):
[List of existing infrastructure]

**Previous Section Prerequisites**:
[List of dependencies on previous sections]

---

### Features & Requirements (INTEGRATED)

#### FR-[N].[M]: [Feature Name]
**Type**: [API/UI/Database/Integration]
**Description**: [What it does]
**Implementation Strategy**: [EXTENSION/NEW]

[Detailed specification with code examples]

---

[More features...]
```

### Required Inputs

1. **SECTION_FILE_PATH**: Path to section file (e.g., `04f-pipeline-build-section-E01.md`)
2. **PRODUCT_ABBREVIATION**: Product code (e.g., `pipeline`, `bmo`)
3. **PREVIOUS_SECTIONS_SUMMARY**: JSON structure of what was built in previous sections
4. **OUTPUT_DIRECTORY**: Where to write generated prompts

---

## Phase 1: Section Analysis

### Step 1.1: Parse Section Metadata

Extract from section file header:

```typescript
interface SectionMetadata {
  sectionNumber: number;           // E.g., 1, 2, 3
  sectionTitle: string;             // E.g., "Foundation & Authentication"
  product: string;                  // E.g., "PIPELINE"
  extensionStatus: string;          // E.g., "Most infrastructure exists"
  originalInfra: string[];          // Generic infrastructure mentioned
  actualInfra: string[];            // What we're actually using
  whatExists: string[];             // Pre-existing components
  whatWeAdd: string[];              // New components in this section
  codebas¬≠ePrereqs: string[];       // Must exist before starting
  previousSectionPrereqs: string[]; // Dependencies on previous sections
}
```

### Step 1.2: Extract Features

Parse all features in the section:

```typescript
interface Feature {
  id: string;                  // E.g., "FR-1.1"
  name: string;                // E.g., "Database Schema for LoRA Training"
  type: FeatureType;           // Database | API | UI | Integration | EdgeFunction
  description: string;         // What it does
  strategy: 'EXTENSION' | 'NEW';
  codeBlocks: CodeBlock[];     // All code examples
  files: FileSpec[];           // Files to create/modify
  dependencies: string[];      // Other feature IDs it depends on
  complexity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
}

interface FileSpec {
  path: string;                // E.g., "src/app/api/datasets/route.ts"
  type: 'NEW' | 'MODIFY';
  purpose: string;             // What this file does
  content?: string;            // Full or partial content from spec
}

interface CodeBlock {
  language: string;            // sql, typescript, tsx, etc.
  label?: string;              // E.g., "Migration File", "API Route"
  content: string;             // The actual code
  filePath?: string;           // Associated file path if specified
}
```

### Step 1.3: Assess Complexity

For each feature, calculate complexity score:

```typescript
function assessComplexity(feature: Feature): ComplexityScore {
  let score = 0;
  
  // Base complexity by type
  if (feature.type === 'Database') score += 2;
  if (feature.type === 'API') score += 3;
  if (feature.type === 'UI') score += 4;
  if (feature.type === 'Integration') score += 5;
  if (feature.type === 'EdgeFunction') score += 6;
  
  // Add for each file
  score += feature.files.length * 1;
  
  // Add for dependencies
  score += feature.dependencies.length * 2;
  
  // Add for code complexity
  const totalCodeLines = feature.codeBlocks
    .reduce((sum, block) => sum + block.content.split('\n').length, 0);
  score += Math.ceil(totalCodeLines / 50);
  
  // Classify
  if (score <= 5) return { level: 'LOW', hours: 1-2 };
  if (score <= 10) return { level: 'MEDIUM', hours: 3-6 };
  if (score <= 15) return { level: 'HIGH', hours: 7-12 };
  return { level: 'CRITICAL', hours: 12+ };
}
```

### Step 1.4: Build Dependency Graph

Create a graph of feature dependencies:

```
FR-1.1 (Database Schema)
  ‚Üì
FR-1.2 (TypeScript Types) ‚Üê depends on FR-1.1
  ‚Üì
FR-2.1 (Upload API) ‚Üê depends on FR-1.1, FR-1.2
  ‚Üì
FR-2.2 (Validation Edge Function) ‚Üê depends on FR-2.1
  ‚Üì
FR-2.3 (Dataset List Page) ‚Üê depends on FR-2.1, FR-2.2
```

---

## Phase 2: Prompt Planning

### Step 2.1: Determine Prompt Grouping Strategy

Based on section complexity, choose a grouping strategy:

**Strategy A: Layer-Based (for complex sections with 6+ features)**
```
Prompt 1: Database Layer (all database features)
Prompt 2: API Layer (all API features)
Prompt 3: UI Foundation (basic UI components)
Prompt 4: Integration Layer (hooks, state, pages)
```

**Strategy B: Feature-Based (for moderate sections with 3-5 features)**
```
Prompt 1: Foundation + Feature 1 (vertical slice)
Prompt 2: Feature 2 (vertical slice)
Prompt 3: Feature 3 + Integration
```

**Strategy C: Single Prompt (for simple sections with 1-2 features)**
```
Prompt 1: Complete section implementation
```

**Selection Criteria:**
```typescript
function selectStrategy(section: ParsedSection): Strategy {
  const totalFeatures = section.features.length;
  const totalComplexityHours = section.features
    .reduce((sum, f) => sum + f.complexity.hours, 0);
  
  if (totalComplexityHours <= 8 && totalFeatures <= 2) {
    return 'SINGLE_PROMPT';
  }
  
  if (totalFeatures >= 6 || totalComplexityHours > 24) {
    return 'LAYER_BASED';
  }
  
  return 'FEATURE_BASED';
}
```

### Step 2.2: Group Features into Prompts

Apply the chosen strategy to create prompt groups:

```typescript
interface PromptGroup {
  promptNumber: number;        // Within this section (1, 2, 3, etc.)
  title: string;               // E.g., "Database Layer"
  features: Feature[];         // Features to implement in this prompt
  estimatedHours: number;      // Total hours for this prompt
  dependencies: {
    previousPrompts: number[]; // Prompt numbers within this section
    previousSections: number[];// Section numbers (E01, E02, etc.)
  };
  deliverables: FileSpec[];    // All files created/modified
}
```

**Grouping Rules:**
1. Keep related features together (e.g., all database work)
2. Respect dependency order (don't build UI before API)
3. Target 6-8 hours per prompt (not too large, not too small)
4. Ensure clear integration points between prompts
5. Allow prompts to be executed in fresh windows (standalone)

### Step 2.3: Define Integration Points

For each prompt, explicitly define what it uses from previous work:

```typescript
interface IntegrationPoint {
  source: {
    section: number;           // Which section (1, 2, 3)
    prompt: number;            // Which prompt within section (1, 2, 3)
    feature: string;           // Feature ID (FR-1.1)
  };
  artifact: {
    type: 'file' | 'table' | 'api' | 'component' | 'hook' | 'type';
    identifier: string;        // Path, name, or identifier
    purpose: string;           // How we'll use it
  };
  usage: string;               // Specific usage description
}
```

Example:
```json
{
  "source": { "section": 1, "prompt": 1, "feature": "FR-1.1" },
  "artifact": {
    "type": "table",
    "identifier": "lora_datasets",
    "purpose": "Store dataset metadata"
  },
  "usage": "Query to fetch user's datasets for listing page"
}
```

---

## Phase 3: Prompt Generation

### Prompt Template Structure

Generate each prompt using this structure:

```markdown
# [Product] - Section E[NN] - Prompt P[MM]: [Title]

**Generated:** [ISO Date]  
**Section:** [N] - [Section Title]  
**Prompt:** [M] of [Total] in this section  
**Estimated Time:** [Hours] hours  
**Prerequisites:** [List of previous prompts/sections]

---

## üéØ Mission Statement

[2-3 sentences: What this prompt accomplishes, why it's important in this section, and how it fits into the overall build]

---

## üì¶ Section Context

### This Section's Goal
[From section overview: What this entire section implements]

### This Prompt's Scope
This is **Prompt [M] of [Total]** in Section E[NN]. It implements:
- [Feature 1 name]
- [Feature 2 name]
- [Feature 3 name]

---

## üîó Integration with Previous Work

### From Previous Sections

[If section > 1, list deliverables from earlier sections that we'll use]

#### Section E[NN-1]: [Title]
**Files We'll Import:**
- `path/to/file.ts` - [Purpose] - [How we'll use it]
- `path/to/component.tsx` - [Purpose] - [How we'll use it]

**Database Tables We'll Query:**
- `table_name` - [Schema summary] - [Queries we'll run]

**APIs We'll Call:**
- `POST /api/endpoint` - [What it does] - [When we'll call it]

**Types We'll Reuse:**
- `TypeName` from `@/lib/types/file` - [Purpose]

### From Previous Prompts (This Section)

[If prompt > 1 within section, list deliverables from earlier prompts in this section]

#### This Section - Prompt P[MM-1]: [Title]
**Deliverables We'll Use:**
- [Specific file or component] - [How we'll use it]

[If this is Prompt 1, state:]
This is the first prompt in Section E[NN]. No previous prompts in this section.

---

## üéØ Implementation Requirements

### Feature FR-[N].[M]: [Feature Name]

**Type:** [Database/API/UI/Integration/EdgeFunction]  
**Strategy:** [EXTENSION - building on existing infrastructure | NEW - creating new component]

#### Description
[Feature description from spec]

#### What Already Exists (Don't Rebuild)
[List what's already in the codebase that this feature uses]
- ‚úÖ [Existing component 1]
- ‚úÖ [Existing component 2]

#### What We're Building (New in This Prompt)
- üÜï [New file 1] - [Purpose]
- üÜï [New file 2] - [Purpose]
- üìù [Modified file 1] - [What we're adding]

#### Implementation Details

[If Database feature:]
**Migration File:** `[path]`

```sql
[SQL code from spec]
```

**Verification:**
```sql
[Queries to verify tables created]
```

[If API feature:]
**File:** `[path]`

**Endpoint:** `[METHOD] /api/[route]`

**Request Schema:**
```typescript
[TypeScript interface from spec]
```

**Response Schema:**
```typescript
[TypeScript interface from spec]
```

**Implementation:**
```typescript
[Full code from spec]
```

**Key Points:**
- Uses: [existing component from previous work]
- Calls: [database table or API]
- Returns: [response format]
- Error handling: [approach]

[If UI feature:]
**Component:** `[ComponentName]`  
**File:** `[path]`  
**Purpose:** [What it does]

**Props Interface:**
```typescript
[Props interface from spec]
```

**Implementation:**
```typescript
[Component code from spec]
```

**Integrations:**
- Imports: `[Component]` from [previous prompt/section]
- Uses hook: `[useHook]` from [previous prompt/section]
- Calls API: `[endpoint]` from [previous prompt/section]

[If EdgeFunction feature:]
**Function:** `[function-name]`  
**File:** `supabase/functions/[function-name]/index.ts`  
**Schedule:** [Cron schedule if applicable]

**Implementation:**
```typescript
[Edge function code from spec]
```

**Deployment:**
```bash
[Deployment commands from spec]
```

[If Integration/Hook feature:]
**Hook:** `[useHookName]`  
**File:** `[path]`  
**Purpose:** [What it provides]

**Implementation:**
```typescript
[Hook code from spec]
```

**Usage Pattern:**
```typescript
[Example usage from spec]
```

---

[Repeat for all features in this prompt]

---

## ‚úÖ Acceptance Criteria

### Functional Requirements
[For each feature, specific criteria from spec]

- [ ] [Feature 1 criterion 1]
- [ ] [Feature 1 criterion 2]
- [ ] [Feature 2 criterion 1]
- [ ] [Integration with previous prompt works]

### Technical Requirements

- [ ] No TypeScript errors
- [ ] No linter warnings  
- [ ] Follows existing patterns from [infrastructure inventory]
- [ ] All imports resolve correctly
- [ ] Code matches specification exactly

### Integration Requirements

- [ ] Successfully imports from [previous prompt file]
- [ ] Successfully queries [database table from previous work]
- [ ] Successfully calls [API from previous work]
- [ ] Navigation flows work (if applicable)

---

## üß™ Testing & Validation

### Manual Testing Steps

1. **Database Verification** (if applicable)
   ```sql
   -- Verify tables exist
   [SQL queries from spec]
   ```

2. **API Testing** (if applicable)
   ```bash
   # Test endpoint with curl
   curl -X POST http://localhost:3000/api/[endpoint] \
     -H "Content-Type: application/json" \
     -d '[test data]'
   ```

3. **UI Testing** (if applicable)
   - Navigate to: `[URL]`
   - Expected behavior: [Description]
   - Verify: [What to check]

4. **Integration Testing**
   - Test connection to [previous prompt deliverable]
   - Verify data flows from [source] to [destination]

### Expected Outputs

After completing this prompt, you should have:
- [ ] All files created at specified paths
- [ ] All modifications to existing files complete
- [ ] Database changes applied (if applicable)
- [ ] Application runs without errors
- [ ] All features testable and working

---

## üì¶ Deliverables Checklist

### New Files Created
[List all new files this prompt creates]

- [ ] `[path/to/file1.ts]` - [Purpose]
- [ ] `[path/to/file2.tsx]` - [Purpose]
- [ ] `[path/to/file3.sql]` - [Purpose]

### Existing Files Modified
[List all files this prompt modifies]

- [ ] `[path/to/existing.ts]` - [What was added]
- [ ] `[path/to/existing.tsx]` - [What was changed]

### Database Changes
[If applicable]

- [ ] Table `[table_name]` created
- [ ] RLS policies enabled on `[table_name]`
- [ ] Indexes created: `[index_names]`

### API Endpoints
[If applicable]

- [ ] `[METHOD] /api/[route]` - [Purpose]

### Components
[If applicable]

- [ ] `[ComponentName]` - [Purpose]
- [ ] Page: `/[route]` - [Purpose]

---

## üîú What's Next

### For Next Prompt in This Section

[If not last prompt in section:]
**Next:** Section E[NN] - Prompt P[MM+1]: [Next prompt title]

This prompt's deliverables will be used by the next prompt for:
- [Specific file that next prompt will import]
- [API that next prompt will call]
- [Component that next prompt will enhance]

[If last prompt in section:]
**Section Complete:** This is the final prompt in Section E[NN].

### For Next Section

[If not last section:]
**Next Section:** E[NN+1]: [Next section title]

The next section will build upon:
- [Key deliverable 1 from this section]
- [Key deliverable 2 from this section]

---

## ‚ö†Ô∏è Important Reminders

1. **Follow the Spec Exactly:** All code provided in this prompt comes from the integrated specification. Implement it as written.

2. **Reuse Existing Infrastructure:** Don't recreate what already exists. Import and use:
   - Supabase Auth via `requireAuth()` from `@/lib/supabase-server`
   - Supabase Client via `createServerSupabaseClient()`
   - shadcn/ui components from `@/components/ui/*`
   - React Query for data fetching

3. **Integration Points:** When importing from previous work, add comments:
   ```typescript
   // From Section E01, Prompt P01 - database schema
   import { Database } from '@/lib/types/database';
   ```

4. **Pattern Consistency:** Match existing patterns:
   - API responses: `{ success: true, data }` or `{ error, details }`
   - File organization: Follow existing structure
   - Component structure: Use existing patterns

5. **Don't Skip Steps:** Implement all features listed in this prompt before moving to the next prompt.

---

## üìö Reference Materials

### Files from Previous Work

[Comprehensive list organized by section and prompt]

#### Section E[NN-1]: [Title]
- `[path/to/file]` - [Purpose] - [Available for import]

#### This Section - Previous Prompts
- `[path/to/file]` - [Purpose] - [Available for import]

### Infrastructure Patterns

[From codebase prerequisites]
- **Authentication:** `requireAuth()` pattern
- **Database:** Supabase client pattern
- **API:** Route handler pattern
- **Components:** shadcn/ui pattern

---

**Ready to implement Section E[NN], Prompt P[MM]!**

---

```

---

## Phase 4: Cross-Prompt Validation

After generating all prompts for a section, validate:

### 4.1 Completeness Check

- [ ] All features from section spec covered
- [ ] All files mentioned in spec included in some prompt
- [ ] All code blocks from spec included in prompts
- [ ] All acceptance criteria from spec included

### 4.2 Dependency Check

- [ ] Prompts in correct order (database ‚Üí API ‚Üí UI ‚Üí integration)
- [ ] No forward dependencies (prompt N doesn't need prompt N+1)
- [ ] All imports reference previously built files
- [ ] All API calls reference previously built endpoints

### 4.3 Integration Check

- [ ] Each prompt explicitly lists what it uses from previous work
- [ ] Integration points are specific (file paths, function names)
- [ ] No duplicate implementations across prompts
- [ ] Clear data flow between prompts

### 4.4 Scope Check

- [ ] Each prompt targets 6-8 hours of work
- [ ] No prompt exceeds 12 hours estimated time
- [ ] Features grouped logically
- [ ] Related features kept together

---

## Phase 5: Section Summary Generation

After all prompts for a section, generate a summary document:

```markdown
# Section E[NN] Summary: [Section Title]

**Product:** [PRODUCT]  
**Section:** [N]  
**Total Prompts:** [M]  
**Estimated Total Time:** [Hours] hours

---

## Section Overview

[From section spec overview]

---

## Prompt Sequence

### Prompt P01: [Title]
**Time:** [Hours] hours  
**Features:** [List]  
**Key Deliverables:** [List]

### Prompt P02: [Title]
**Time:** [Hours] hours  
**Features:** [List]  
**Key Deliverables:** [List]  
**Dependencies:** P01

[Continue for all prompts...]

---

## Complete Deliverables List

### Database
- Table: `[table_name]` (Prompt P[N])
- [More tables...]

### API Endpoints
- `[METHOD] /api/[route]` (Prompt P[N])
- [More endpoints...]

### Components
- `[ComponentName]` at `[path]` (Prompt P[N])
- [More components...]

### Pages
- `/[route]` (Prompt P[N])
- [More pages...]

---

## Integration with Other Sections

### Dependencies (What This Section Needs)
- From Section E[NN-1]: [List of files, tables, APIs]

### Provides (What Next Sections Will Use)
- For Section E[NN+1]: [List of files, tables, APIs, components]

---

## Verification Checklist

After completing all prompts in this section:

- [ ] All tables created and verified
- [ ] All API endpoints tested
- [ ] All components render correctly
- [ ] All pages accessible
- [ ] Integration with previous sections works
- [ ] No TypeScript errors
- [ ] No linter warnings

---

```

---

## Output File Structure

Generate a **single file** for each section with all progressive prompts:

**File Path Format:**
```
pmc/product/_mapping/[product-abbrev]/full-build/04f-[product-abbrev]-build-section-E[NN]-execution-prompts.md
```

**Example Outputs:**
```
pmc/product/_mapping/pipeline/full-build/
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E01.md                    # Section spec (already exists)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E01-execution-prompts.md  # Progressive prompts (output)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E02.md                    # Section spec (already exists)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E02-execution-prompts.md  # Progressive prompts (output)
‚îî‚îÄ‚îÄ ...
```

### Execution Prompts File Structure

The output file should contain all prompts for the section in a single document:

```markdown
# [Product] - Section E[NN]: [Title] - Execution Prompts

**Product:** [PRODUCT]  
**Section:** [N] - [Section Title]  
**Generated:** [Date]  
**Total Prompts:** [M]  
**Estimated Total Time:** [Hours] hours  
**Source Section File:** 04f-[product]-build-section-E[NN].md

---

## Section Overview

[From section spec overview - what this entire section implements]

---

## Prompt Sequence for This Section

This section has been divided into [M] progressive prompts:

1. **Prompt P01: [Title]** ([hours]h)
   - Features: [List]
   - Key Deliverables: [List]

2. **Prompt P02: [Title]** ([hours]h)
   - Features: [List]
   - Key Deliverables: [List]
   - Dependencies: P01

[Continue for all prompts in this section...]

---

## Integration Context

### Dependencies from Previous Sections
[List what this section needs from earlier sections]

### Provides for Next Sections
[List what future sections will use from this section]

---

## Dependency Flow (This Section)

```
E[NN]-P01 ([Feature])
  ‚Üì
E[NN]-P02 ([Feature]) ‚Üê uses E[NN]-P01
  ‚Üì
E[NN]-P03 ([Feature]) ‚Üê uses E[NN]-P01, E[NN]-P02
```

---

# PROMPT 1: [Title]

[Full prompt using template from Phase 3]

---

# PROMPT 2: [Title]

[Full prompt using template from Phase 3]

---

[Continue for all prompts...]

---

## Section Completion Checklist

After completing all prompts in this section:

- [ ] All features implemented
- [ ] All files created/modified
- [ ] All tests passing
- [ ] Integration with previous sections verified
- [ ] Ready to proceed to Section E[NN+1]

---

**End of Section E[NN] Execution Prompts**

```

---

## Meta-Prompt Usage Examples

### Example 1: Single Section

**Input:**
- Section File: `pmc/product/_mapping/pipeline/full-build/04f-pipeline-build-section-E01.md`
- Product: `pipeline`

**Process:**
Apply this meta-prompt to the section file following all phases (Analysis ‚Üí Planning ‚Üí Generation ‚Üí Validation)

**Output:**
- File: `pmc/product/_mapping/pipeline/full-build/04f-pipeline-build-section-E01-execution-prompts.md`
- Contains: 2 prompts (P01: Database Foundation - 3h, P02: TypeScript Types - 2h)
- Total: 5 hours of work in a single document

### Example 2: All Sections

**Input:**
- All section files in `pmc/product/_mapping/pipeline/full-build/`
- Product: `pipeline`

**Process:**
Apply this meta-prompt to each section file sequentially

**Output:**
```
pmc/product/_mapping/pipeline/full-build/
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E01.md                    (Section spec)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E01-execution-prompts.md  (2 prompts, 5h)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E02.md                    (Section spec)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E02-execution-prompts.md  (3 prompts, 18h)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E03.md                    (Section spec)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E03-execution-prompts.md  (4 prompts, 24h)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E04.md                    (Section spec)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E04-execution-prompts.md  (3 prompts, 20h)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E05.md                    (Section spec)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E05-execution-prompts.md  (3 prompts, 18h)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E06.md                    (Section spec)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E06-execution-prompts.md  (2 prompts, 10h)
‚îú‚îÄ‚îÄ 04f-pipeline-build-section-E07.md                    (Section spec)
‚îî‚îÄ‚îÄ 04f-pipeline-build-section-E07-execution-prompts.md  (1 prompt, 5h)

Total: 7 execution-prompts files, 18 prompts across 7 sections, ~100 hours
```

---

## Success Criteria

This meta-prompt is successful when:

1. ‚úÖ **Analyzes section files correctly** - extracts all features, code, files
2. ‚úÖ **Groups features logically** - based on type and dependencies  
3. ‚úÖ **Generates executable prompts** - each prompt is standalone with full context
4. ‚úÖ **Maintains integration** - explicit references to previous work
5. ‚úÖ **No redundancy** - each feature implemented once
6. ‚úÖ **Clear dependencies** - obvious what needs to be built first
7. ‚úÖ **Reasonable scope** - prompts are 6-8 hours each
8. ‚úÖ **Complete coverage** - all features from section included
9. ‚úÖ **Works across sections** - handles inter-section dependencies
10. ‚úÖ **Progressive enhancement** - each prompt builds on previous

---

## Version History

**v2.0** - December 25, 2025
- Redesigned for integrated specification section files
- Support for inter-section and intra-section dependencies
- Handles structured input format from segmentation script
- Optimized for progressive build across multiple sections
- Code extraction and integration from detailed specs

**v1.0** - December 21, 2025 (deprecated)
- Worked with unstructured specifications
- Required extensive analysis phase
- Not optimized for segmented section files

---

**End of Meta-Prompt v2.0**

